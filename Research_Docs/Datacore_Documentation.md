# Datacore Plugin for Obsidian: Comprehensive Technical Documentation for AI Agents

## Overview

Datacore is a high-performance metadata indexing and query engine for that provides 2-10x better performance than its predecessor, Dataview. It creates dynamic, live-updating views of vault data using React-based JavaScript components. This documentation is designed for AI agents to understand and generate valid Datacore queries and views.[github](https://github.com/blacksmithgu/datacore)

## Installation Context

Datacore is installed via Obsidian Community Plugins or BRAT plugin (for beta versions). Once enabled, it indexes all vault files in the background, creating a searchable metadata database.

## Core Architecture

## Metadata System

Datacore indexes **all** content in your vault into a hierarchical metadata structure

**Indexed Objects:**

- Markdown pages
- Sections within pages
- Blocks
- List items
- Tasks
- Canvas files
- PDFs
- Images
- Other attachments

**Metadata Types:**

1. **Intrinsic Metadata** (prefixed with `$`): Automatically generated by Datacore
2. **User Metadata**: Custom properties defined in frontmatter or inline fields

**Why `$` prefix?** Differentiates intrinsic fields from user-defined properties, allowing users to have properties like `path` separate from `$path`.

## Universal Intrinsic Metadata Fields

All Datacore objects contain these standard fields:[blacksmithgu.github](https://blacksmithgu.github.io/datacore/data)

## `$types` (Array<string>)

**Purpose:** Describes what type(s) an object is

**Examples:**

- Markdown pages: `["page", "markdown", "file", "taggable", "linkable"]`
- Sections: `["section", "markdown"]`
- Tasks: `["task", "list-item", "markdown"]`

**Usage in Queries:** Filter by type using `@type` syntax

## `$name` (string)

**Purpose:** The display name/title of the object

**Example:** `"Dark Souls"` for a file named "Dark [Souls.md](http://Souls.md)"

## `$path` (string)

**Purpose:** Full file path within the vault

**Example:** `"games/Dark Souls.md"`

**Note:** Available for file-level objects (pages, images, canvas, PDFs)

## `$file` (string)

**Purpose:** File path that the object came from

**Note:** Available on all objects, even sub-file objects like sections

## `$tags` (Array<string>)

**Purpose:** De-duplicated list of all tags in the object

**Example:** `["#game", "#game/hard"]`

**Available on:** All taggable objects

## `$links` (Array<LinkObject>)

**Purpose:** De-duplicated list of all links the object contains

**Structure:** `[{ path: "target/file.md" }, ...]`

**Available on:** All linkable objects

## `$parent` (Object | null)

**Purpose:** Reference to the parent object in the hierarchy

**Example:** A section's `$parent` points to its containing page

**Hierarchy:** Page → Sections → Blocks → List Items/Tasks

## `$sections` (Array<Object>)

**Purpose:** Child sections of a page

**Available on:** Page objects

## `$frontmatter` (Object)

**Purpose:** Contains all YAML frontmatter properties

**Example:** `{ "length": "35 hours", "rating": 10, "time-played": "2013-06-10" }`

## `$link` (ReactElement)

**Purpose:** Rendered link component to the object

**Usage:** Display in tables and views as clickable links

## Code Block Syntax

All Datacore views are created using code blocks with the `datacorejsx` language identifier:[blacksmithgu.github](https://blacksmithgu.github.io/datacore/quickstart)

`text``` // Your JavaScript/React code here return function View() { // Component logic return <JSX>; }

```

**Critical Requirements:**

1. Must return a **function** named `View` or any name
2. The function must return valid JSX/React elements
3. Use the global `dc` object to access Datacore API

## Query Language: `dc.useQuery()`

## Basic Syntax

`javascriptconst results = dc.useQuery(queryString);`

**Parameters:**

- `queryString` (string): The query expression to filter objects

**Returns:** Array of matching objects

## Query String Syntax

## Type Queries (using `@`)

**Format:** `@typeName`

**Available Types:**

- `@page` - Markdown pages
- `@section` - Page sections
- `@task` - Tasks
- `@list-item` - List items
- `@block` - Blocks
- `@canvas` - Canvas files
- `@markdown` - All markdown-based objects
- `@file` - All file objects

**Examples:**

`javascriptdc.useQuery("@page")           *// All pages*
dc.useQuery("@task")           *// All tasks*
dc.useQuery("@section")        *// All sections*`

## Tag Queries

**Format:** `#tagName` or `#nested/tag`

**Examples:**

`javascriptdc.useQuery("#game")           *// Objects with #game tag*
dc.useQuery("#project/active") *// Objects with nested tag*`

## Boolean Operators

**Operators:** `and`, `or`, `not`

**Examples:**

`javascript*// AND operator*
dc.useQuery("@page and #game")

*// OR operator*
dc.useQuery("#status/open or #status/wip")

*// Complex expressions*
dc.useQuery("(@page and #assignment) or (#project and not #archived)")`

## Folder Queries

**Format:** Use quotes for folder paths

**Examples:**

`javascriptdc.useQuery('"Books"')                    *// Pages in Books folder*
dc.useQuery('"30 School/32 Homeworks"')   *// Nested folder path*`

## Combined Queries

**Examples:**

`javascript*// Type + Tag*
dc.useQuery("@page and #game")

*// Type + Folder*
dc.useQuery('@page and "Projects"')

*// Complex multi-condition*
dc.useQuery('(@page and #game and "games") or (@task and not done)')`

## React Hooks API

## `dc.useQuery(queryString)`

**Purpose:** Fetch and subscribe to query results with live updates

**Characteristics:**

- Returns reactive data that updates when vault changes
- Automatically re-renders component on data changes
- More performant than Dataview's `dv.pages().where()`

**Example:**

`javascriptreturn function View() {
  const pages = dc.useQuery("@page and #project");
  return <div>{pages.length} projects found</div>;
}`

## `dc.useArray(dataArray, transformFunction)`

**Purpose:** Transform query results using DataArray-specific functions

**Use Case:** When you need `DataArray.groupBy()` or array manipulation methods

**Example:**

`javascriptreturn function View() {
  const pages = dc.useQuery("@page");
  const sortedPages = dc.useArray(pages, array => 
    array.sort(page => page.$name)
  );
  return <div>*/* render sortedPages */*</div>;
}`

## `dc.useState(initialValue)`

**Purpose:** Create reactive state within Datacore views

**Returns:** `[value, setValue]` tuple (standard React state)

**Example:**

`javascriptreturn function View() {
  const [filter, setFilter] = dc.useState("");
  return (
    <input 
      value={filter} 
      onChange={(e) => setFilter(e.target.value)} 
    />
  );
}`

## `dc.useMemo(computeFunction, dependencies)`

**Purpose:** Memoize expensive computations

**Parameters:**

- `computeFunction`: Function to compute value
- `dependencies`: Array of values that trigger recomputation

**Example:**

`javascriptreturn function View() {
  const pages = dc.useQuery("@page");
  const [filter, setFilter] = dc.useState("");
  
  const filteredPages = dc.useMemo(() => {
    if (!filter) return pages;
    return pages.filter(p => 
      p.$name?.toLowerCase().includes(filter.toLowerCase())
    );
  }, [filter, pages]);
  
  return <div>*/* render filteredPages */*</div>;
}`

## Built-in Components

## `<dc.VanillaTable>`

**Purpose:** Render objects in a table with built-in sorting and pagination

**Props:**

- `columns` (Array<ColumnDefinition>): Column specifications
- `rows` (Array<Object>): Data to display

**Column Definition Structure:**

`javascript{
  id: string,           *// Column header text*
  value: (row) => any   *// Function to extract cell value from row*
}`

**Complete Example:**

`javascriptconst COLUMNS = [
  { id: "Name", value: row => row.$link },
  { id: "Path", value: row => row.$path },
  { id: "Rating", value: row => row.value("rating") },
  { id: "Tags", value: row => row.$tags.join(", ") }
];

return function View() {
  const pages = dc.useQuery("@page and #game");
  return <dc.VanillaTable columns={COLUMNS} rows={pages} />;
}`

## Accessing Object Properties

## Intrinsic Properties (Direct Access)

`javascriptpage.$name        *// String*
page.$path        *// String*
page.$tags        *// Array*
page.$links       *// Array*
page.$types       *// Array*
page.$parent      *// Object or null*
page.$link        *// ReactElement*`

## User-Defined Properties (via `.value()`)

**Method:** `object.value(propertyName)`

**Example:**

`javascriptpage.value("rating")        *// Access frontmatter: rating*
page.value("length")        *// Access frontmatter: length*
page.value("time-played")   *// Access frontmatter: time-played*`

**Why `.value()`?** Safely accesses user properties that might not exist, returning `undefined` if missing.

## Array Manipulation Methods

Query results are arrays that support JavaScript array methods:

## `.length`

`javascriptconst count = dc.useQuery("@page").length;`

## `.filter()`

`javascriptconst pages = dc.useQuery("@page");
const highRated = pages.filter(p => p.value("rating") >= 8);`

## `.map()`

`javascriptconst pages = dc.useQuery("@page");
const names = pages.map(p => p.$name);`

## `.sort()`

`javascriptconst sorted = pages.sort((a, b) => 
  a.$name.localeCompare(b.$name)
);`

## Using `dc.useArray()` for DataArray Methods

`javascriptconst sorted = dc.useArray(pages, array => 
  array.sort(page => page.$name)
);

const grouped = dc.useArray(pages, array =>
  array.groupBy(page => page.value("category"))
);`

## Complete Examples

## Example 1: Simple Page Counter

`javascriptreturn function View() {
  const pages = dc.useQuery("@page").length;
  return <p>You have {pages} pages in your vault!</p>;
}`

## Example 2: Table with Multiple Columns

`javascriptconst COLUMNS = [
  { id: "Name", value: row => row.$link },
  { id: "Rating", value: row => row.value("rating") },
  { id: "Status", value: row => row.value("status") }
];

return function View() {
  const pages = dc.useQuery("@page and #game");
  return <dc.VanillaTable columns={COLUMNS} rows={pages} />;
}`

## Example 3: Filtered and Sorted List

`javascriptreturn function View() {
  const pages = dc.useQuery("@page and #project");
  
  const sortedPages = dc.useArray(pages, array =>
    array.sort(page => page.$name)
  );
  
  return (
    <ul>
      {sortedPages.map(page => (
        <li key={page.$path}>{page.$link}</li>
      ))}
    </ul>
  );
}`

## Example 4: Search with Filter

`javascriptconst COLUMNS = [
  { id: "Name", value: row => row.$name },
  { id: "Link", value: row => row.$link },
  { id: "Path", value: row => row.$path }
];

return function View() {
  const pages = dc.useQuery("@page");
  const [filter, setFilter] = dc.useState("");
  
  const filteredPages = dc.useMemo(() => {
    if (!filter) return pages;
    return pages.filter(obj => 
      obj.$name?.toLowerCase().includes(filter.toLowerCase()) ||
      obj.$path?.toLowerCase().includes(filter.toLowerCase())
    );
  }, [filter, pages]);
  
  return (
    <div>
      <input 
        type="text" 
        placeholder="Search..." 
        value={filter}
        onChange={(e) => setFilter(e.target.value)}
      />
      <dc.VanillaTable columns={COLUMNS} rows={filteredPages} />
    </div>
  );
}`

## Example 5: Task List

`javascriptreturn function View() {
  const tasks = dc.useQuery("@task");
  
  return (
    <div>
      <h3>All Tasks ({tasks.length})</h3>
      <ul>
        {tasks.map((task, index) => (
          <li key={index}>
            {task.$text} - {task.$file}
          </li>
        ))}
      </ul>
    </div>
  );
}`

## Example 6: Grouped by Tag

`javascriptreturn function View() {
  const pages = dc.useQuery("@page");
  
  const grouped = dc.useArray(pages, array =>
    array.groupBy(page => page.$tags[0] || "untagged")
  );
  
  return (
    <div>
      {Object.entries(grouped).map(([tag, items]) => (
        <div key={tag}>
          <h3>{tag} ({items.length})</h3>
          <ul>
            {items.map(item => (
              <li key={item.$path}>{item.$link}</li>
            ))}
          </ul>
        </div>
      ))}
    </div>
  );
}`

## Query Patterns for Common Use Cases

## Get all pages

`javascriptdc.useQuery("@page")`

## Get pages with specific tag

`javascriptdc.useQuery("@page and #tagname")`

## Get pages in folder

`javascriptdc.useQuery('@page and "folder/path"')`

## Get pages with multiple conditions

`javascriptdc.useQuery("@page and #project and not #archived")`

## Get all tasks

`javascriptdc.useQuery("@task")`

## Get incomplete tasks with tag

`javascriptdc.useQuery("@task and #important and not done")`

## Get pages OR tasks

`javascriptdc.useQuery("@page or @task")`

## Get pages in multiple folders

`javascriptdc.useQuery('@page and ("folder1" or "folder2")')`

## Performance Considerations

1. **Indexing Time:** Initial vault indexing may take several minutes
2. **Query Performance:** 2-10x faster than Dataview
3. **Live Updates:** Views automatically update when vault changes
4. **Memoization:** Use `dc.useMemo()` for expensive computations
5. **Pagination:** Built into `<dc.VanillaTable>` (default: 25 rows per page)

## Best Practices for AI Agents

## When Generating Queries

1. **Always specify type first:** `@page`, `@task`, `@section`
2. **Use `and` for combining conditions:** More predictable than nesting
3. **Quote folder paths:** Always use quotes around folder names
4. **Check property existence:** Use `.value()` for user properties
5. **Provide fallbacks:** Handle cases where properties might be undefined

## When Building Views

1. **Always return a function component**
2. **Use descriptive variable names** for clarity
3. **Memoize filtered/sorted results** for performance
4. **Include error handling** for missing properties
5. **Test with empty results** (what if query returns no items?)

## Column Definitions

`javascript*// GOOD: Safe property access*
{ id: "Rating", value: row => row.value("rating") ?? "N/A" }

*// GOOD: Intrinsic property*
{ id: "Name", value: row => row.$name }

*// GOOD: Link rendering*
{ id: "Link", value: row => row.$link }

*// GOOD: Array joining*
{ id: "Tags", value: row => row.$tags.join(", ") }`

## Error Prevention

## Common Mistakes to Avoid

1. **Missing `return function`:** Views must return a function component

`javascript*// WRONG*
const pages = dc.useQuery("@page");
return <div>{pages.length}</div>;

*// CORRECT*
return function View() {
  const pages = dc.useQuery("@page");
  return <div>{pages.length}</div>;
}`

1. **Direct property access for user metadata:**

`javascript*// RISKY*
page.rating  *// May not exist// SAFE*
page.value("rating")`

1. **Forgetting quotes in folder queries:**

`javascript*// WRONG*
dc.useQuery("@page and Projects")

*// CORRECT*
dc.useQuery('@page and "Projects"')`

1. **Missing key props in lists:**

`javascript*// WRONG*
{pages.map(page => <li>{page.$name}</li>)}

*// CORRECT*
{pages.map(page => <li key={page.$path}>{page.$name}</li>)}`

## Hierarchical Data Access

## Accessing Parent Objects

`javascriptconst section = dc.useQuery("@section")[0];
const parentPage = section.$parent;  *// Get containing page*`

## Accessing Child Objects

`javascriptconst page = dc.useQuery("@page")[0];
const sections = page.$sections;  *// Array of sections in page*`

## Summary for AI Agents

**To create valid Datacore views:**

1. Use `datacorejsx` code blocks
2. Return a function component
3. Query data with `dc.useQuery(queryString)`
4. Use `@type` for filtering by object type
5. Access intrinsic properties with `$` prefix directly
6. Access user properties with `.value(propertyName)`
7. Render tables with `<dc.VanillaTable columns={} rows={} />`
8. Use React hooks (`dc.useState`, `dc.useMemo`) for interactivity
9. Handle edge cases (empty results, missing properties)
10. Provide valid JSX with proper key props in lists

**Query syntax priority:**

- Type queries: `@page`, `@task`, `@section`
- Tag queries: `#tagname`
- Folder queries: `"folder/path"`
- Boolean operators: `and`, `or`, `not`
- Parentheses for grouping: `(condition1 and condition2) or condition3`

This documentation provides complete context for generating syntactically correct and semantically meaningful Datacore queries and views.